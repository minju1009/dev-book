이터레이션 프로토콜을 따르는 객체는 for...of  / spread  연산자에서 사용할 수 있다
- 순회가 가능한 규칙, 규격
Array, String, Map, Set


- 순회가 가능한 객체가 되려면 Iterable 프로토콜을 따라야 하는데 객체 안에서 [Symbol.iterator]() () : Iterator 프로토콜 (반복자를 리턴하는 객체를 만들면!) 된다.
	- 객체 안에서 Symbol.iterator라는 함수를 만들고
	- 그 함수가 반복자를 리턴하도록 하면 된다.
	- 반환되는 Iterator 프로토콜을 따른다는 것은?
	- 객체 안에서 next(): 다음값을 리턴하는 객체를 만들면 된다.

1) Iterable 프로토콜 : Symbol.iterator
2) Iterator 프로토콜 : next를 반환하는 객체

```js
const array = [1,2,3];
for(const item of array) {
	console.log(item);
}

const iterator = array1.values();
for(const value of iterator){
	console.log(value);
}
```

Iterable 하다는 것은! 순회가 가능하다는 거지!
[Symbol.iterator]() 를 호출했을 때, Iterator를 반환하면 되는 것!
다시 말해, 심볼 정의를 가진 객체나, 특정한 함수가 Iterator를 리턴하는 것은 순회가능한 객체이다 라는 것을 알 수있다.
순회가 가능하면 무엇을 할 수 있나? for..of, spread 연산자를 사용할 수 있다.

```js
// 이터러블이 아닌 일반 객체는 for..of 사용 안되고, for..in만 사용할 수 있다.
const obj = { 0: 1, 1: 2};
for(const item in obj){
	console.log(item);   // key를 출력
}

// 따라서 유사배열 객체는 배열이 아니라서 반복되는 것 사용 못하겠지?
```


### 이터러블 자세히 뜯어보기
Iterator 
next 필수! 
return - 옵션
throw - 옵션

```js
const iterator = array.values();
for (const item of iterator) {
	console.log(item)
}

console.log(iterator.next());   // {done : true/false, value: 값}
console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);  // done은 true가 되어 반복이 끝났음을 알 수 있다. 
```

```js
const iterator = array.values();
while (true) {
	const item = iterator.next();
	if(item.done) break;
	console.log(item.value);
}

```

## 이터러블 만들어보기 - 나만의 이터러블을 만들어보자!
```js
// 0부터 10이하까지 숫자의 2배를 순회하는 이터레이터(반복자) 만들기!
// 0, 2, 4, 6, ...., 18
// [Symbol.iterator]() : Iterator{next() : {value, done}};

const multiple = {
	[Symbol.iterator]() {
		const max = 10;
		let num = 0;
		return {
			next() {
				return {value: num++ * 2, done: num > max}
			}
		}
	}

}

for(const num of multiple){
	console.log(num);
}
```

### 이터레이션을 재사용 가능하도록 함수로 만들기
```js
function makeIterable(InitailValue, maxValue, callback){
return {
	[Symbol.iterator]() {
		const max = maxValue;
		let num = initialValue;
		return {
			next() {
				return {value: callback(num++), done: num > max}
			}
		}
	}
}
}

const multiple = makeIterable(0, 20, (n) => n * 2);
for(const num of multiple){
	console.log(num)
}

```