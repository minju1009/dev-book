함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다.

# 01 상황에 따라 달라지는 this
- this는 기본적으로 실행 컨텍스트가 생성될 때, 즉 함수를 호출할 때 함께 결정된다.
- 더 구체적으로 말하면, `함수를 어떤 방식으로 호출`하느냐에 따라 값이 달라진다.

## 1 전역 공간에서의 this
- 전역공간에서 this는 `전역 객체` 를 가리킨다. 개념상 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문이다.
- 전역 객체는 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있는데, 브라우저 환경에서는 window이고 Node.js 환경에서는 global이다.
- 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.
```js
var a = 1;
console.log(a, window.a, this.a)  // 1 1 1 
```

그런데 전역변수 선언과 전역객체의 프로퍼티 할당 사이에 전혀 다른 경우도 있다. 바로 '삭제'명령에 대해 다르게 작동하는데, `전역변수로 선언한 경우에는 삭제가 되지 않고, 전역객체의 프로퍼티로 할당한 경우에만 삭제가 가능`하다. 즉, 전역변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 configurable 속성을 false로 정의하는 것이다.

## 2 메서드로서 호출할 때 메서드 내부에서의 this
### 함수 vs 메서드

> 어떠한 함수를 호출할 때 그 함수 이름(프로퍼티명) 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것, 그렇지 않은 모든 경우에는 함수로 호출한 것이다.

### 메서드 내부에서의 this
this에는 `호출한 주체에 대한 정보`가 담긴다. 따라서, 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체이다. 
```js
var obj = {
    methodA: function(){console.log(this)}   // this는 obj이다.
};
```

주의할 점은, 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라, `객체의 메서드로서 호출할 경우에만 메서드로 동작` 하고, 그렇지 않으면 함수로 작동한다는 것이다.

```js
var func = function(x){
	console.log(this, x);
};
func(1);            // this는 Window

var obj = {
	method: func
};
obj.method(2);     // this는 obj 

```

## 3 함수로서 호출할 때 그 함수 내부에서의 this
### 함수 내부에서의 this
- 어떤 함수를 함수로서 호출한 경우에는 this가 지정되지 않는다. this에는 호출한 주체가 담기는데, 일반 함수로 호출하는 것은 호출 주체를 명시하지 않고, 개발자가 직접 관여해서 실행한 것이기 때문에 `호출 주체의 정보를 알 수 없는 것`이다. 
- 따라서 함수에서의 this는 `전역 객체`를 가리킨다.

### 메서드의 내부함수에서의 this
- this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고, 오직 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건이다!!

```js
var obj1 = {
	outer: function() {
		console.log(this);                 // obj1(1)
		var innerFunc = function () {
			console.log(this);            // Window(2), obj2(3)
		}
		innerFunc();  // 일반 함수로 호출(2)
		
		var obj2 = {
			innerMethod: innerFunc
		};
		obj2.innerMethod();  // 메서드로 호출(3)
	}
}
obj1.outer(); // 메서드로 호출(1)
```

### 메서드의 내부 함수에서의 this를 우회하는 방법
호출 주체가 없을 때에는 자동으로 전역객체를 바인딩하지 않고 호출 당시의 주변 환경의 this를 그대로 상속받아 사용할 수 있다면 좋을 것 같다. 변수를 검색하면 스코프체인을 따라 검색하듯이, this 역시 현재 컨텍스트에 바인딩된 대상이 없으면 직전 컨텍스트의 this를 바라보도록 말이다.

ES5까지는 내부함수에 this를 상속할 방법이 없지만, 우회하는 방법이 있는데, 대표적인 것은 변수를 활용하는 것이다.

```js
var obj = {
	outer: function (){
		console.log(this);
		var innerFunc1 = function (){
			console.log(this);             // 함수로 호출했기에 기본적으로 Window가 출력
		}
		innerFunc();

		var self = this;                   // *현재의 this인 obj를 self라는 변수에 저장
		var innerFunc2 = function() {
			console.log(self);             // 함수로 호출했지만, obj가 출력
		}
		innerFunc2();
	}
}
obj.outer();
```

### this를 바인딩하지 않는 함수
ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자, this를 바인딩하지 앟는 화살표 함수를 새로 도입했다. 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다. ( 앞에서 본 '우회법'이 불필요해진다.)

```js
var obj = {
	outer : function() {
		console.log(this);          // this는 obj
		var innerFunc = () => {
			console.log(this);      // this는 obj!!!!!
		}
		innerFunc();                 // 함수로서 호출
	}
}
obj.outer();
```

그 밖에도 call, apply 등의 메서드를 활용해 함수 호출할 때 명시적으로 this를 지정하는 방법이 있다.

## 4 콜백 함수 호출 시 그 함수 내부에서의 this
- 콜백 함수도 함수이기 때문에 기본적으로 this가 전역객체를 참조한다.
- 그러나, 제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 된다.

## 5 생성자 함수 내부에서의 this
- 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 된다.
- 생성자 함수를 호출하면 우선 생성자의 prototype 프로퍼티를 참조하는 `__proto__`라는 프로퍼티가 있는 객체(인스턴스)를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여한다. 이렇게 해서 구체적인 인스턴스가 만들어진다.
```js
var Cat = function (name, age){
	this.bark = '야옹';
	this.name = name;
	this.age = age;
}

var choco =  new Cat('초코', 7);   // 여기서 this는 인스턴스 choco를 가리킴
var nabi = new Cat('나비', 3);     // 여기서 this는 인스턴스 nabi를 가리킴

```
   