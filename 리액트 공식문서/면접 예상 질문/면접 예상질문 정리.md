### 1. 프레임 워크, 라이브러리의 차이?
- 프레임워크는 소프트웨어 개발을 위한 구조와 기능을 제공하는 플랫폼이며, 라이브러리는 개발자가 사용할 수 있는 기능을 모아놓은 코드의 집합이다. 
- 즉, 프레임워크에서는 `IoC(Inversion of Control`을 이용하여 컴퓨터 프로그램의 제어 흐름을 프레임워크가 담당하도록 하며, 라이브러리는 개발자가 코드를 제어한다.

### 2. 메타 프레임워크란?
- 다른 프레임워크를 개발하기 위한 기반을 제공하는 프레임워크다. 프레임워크를 개발하는 데 사용되는 도구, 패턴, 추상화 계층 등을 포함한다.
- 리액트의 경우 Next.js, Gatsby, Remix, 뷰의 경우 Nuxt.js 

### 3. 선언형 프로그래밍 vs 명령형 프로그래밍
- 선언형 프로그래밍은 `원하는 결과물을 선언`하는 방식의 프로그래밍 패러다임이며, 명령형 프로그래밍은 프로그래밍이 `어떻게 동작해야 하는지를 명시`하는 프로그래밍 패러다임이다.
- 리액트에서는 선언형 프로그래밍 방식으로 코드를 작성한다. 

### 4. 에러를 명령형으로 처리했던 경험과 선언형으로 처리했던 경험이 있나?
- 에러 바운더리로 처리할 수 있는 방법이 있는데, 기존 에러바운더리는 클래스에서만 사용 가능했다. 
- `이번 프로젝트때 센트리 사용해보고 답변 정리하기!`
- [https://www.youtube.com/watch?v=012IPbMX_y4](https://www.youtube.com/watch?v=012IPbMX_y4)

### 5. Suspense란?
- 리액트의 Suspense는 비동기 데이터 로딩 및 코드 스플리팅과 같은 선언형 프로그래밍을 지원하기 위한 리액트의 기능으로, 선언적인 방식으로 컴포넌트가 비동기 작업을 수행할 때 로딩 상태를 처리하고, 로딩이 완료된 후에 UI를 렌더링하는데 사용된다.

### 6. 리액트에서 리렌더링을 할 때 왜 setState를 사용하는지?
- 데이터가 변경되었다는 것을 React에게 알려줘야하기 때문이다. setState를 통해 React에게 변경사항을 알려 가상돔에 반영하고 화면을 리렌더링할 수 있기 때문이다.

### 7. 리액트 state를 사용할 때, 왜 불변성을 사용하는지?
- state의 세부 내용을 일일이 비교하기 보다, 기존 state의 불변성을 지켜주고 새로운 주소값을 이용해 state를 업데이트 해주는 것이 성능적으로 더 좋기 때문이다. 특히 데이터가 대용량일 때, 일일이 하나씩 찾아서 비교하는 것은 비용이 굉장히 비싸지는데, 그렇기에 리액트는 얕은복사를 통해 데이터의 변경을 감지하도록 한다.

### 8 . JSX란?
- JSX란 자바스크립트와 XML을 결합한 문법으로, JSX를 이용하면 인간이 이해하기 쉬운 방식으로 돔 조작과 자바스크립트의 사용을 한 공간에서 손쉽게 작성할 수 있다. 또한 선언적인 방식으로 작성하기에 가독성도 좋다.

### 9. React.createElement vs `_jsx
- 리액트 16버전까지는 컴포넌트에 React를 import 해서 React.createElement() 함수로 JSX를 변환했다. 그러나 17버전부터는 내부적으로 _jsx함수를 통해 JSX를  변환하므로, React를 import하는 문을 따로 사용하지 않아도 되게 변경되었다.
```js
import { jsx as _jsx } from "react/jsx-runtime"; // 이 코드를 따로 넣어주지 않아도 react에서 자체적으로 넣는다.
```

### 10. JSX -> 자바스크립트로는 뭘 통해서 변경되는 것인가?
- 바벨 혹은 tsc에서 변환해주는 역할을 한다. 바벨 안에 `@babel/preset-react`를 통해 변경이 되는 것이다.

### 11. JSX 안에 조건문이나 반복문, for문을 쓸 수 없다. 그 이유는?
- JSX는 결국 createElement혹은 _jsx로 변환되는데, JSX가 쓴 구문이 해당 함수들의 파라미터로 들어가는 `값`이기 때문이다. 따라서 값으로 평가될수 있는 문, 즉 표현식만 JSX로 사용할 수 있고, 값으로 평가되지 안는 일반 조건문이나 반복문 등은 JSX 안에서 사용할 수 없다.
- https://babeljs.io/docs/babel-plugin-transform-react-jsx 참고

### 12. ref란 무엇인지?
- 특정 정보를 기억하도록 하고 싶지만 해당 정보가 새 렌더링을 촉발하지 않도록 하려는 경우에 사용한다. 단순한 객체이며 변이가 가능하다.

### 13. 컴포넌트 밖에 변수로 선언해도 리렌더링을 하지 않는데, 왜 굳이 ref를 사용하는 것인지?
- 컴포넌트 밖에 변수로 데이터를 선언하면 해당 변수는 여러 컴포넌트에서 참조가 가능하다. 컴포넌트 내부에서 독자적으로 컴포넌트가 상태를 가지고 있게 하려면 ref를 사용해야 한다.

### 14. callback ref가 무엇이고 왜 필요한지?
- ref속성에 객체 대신 함수를 전달하는 것을 callback ref라고 한다. 해당 DOM노드가 화면에 추가될 때 React는 DOM node를 인수로 사용하여 ref 콜백을 호출하고 해당 DOM 노드가 제거될 때 React는 null로 ref 콜백을 호출한다. 
- 하위 컴포넌트에 동적으로 DOM이 생성되어 어떤 DOM이 들어올지 모르나 그 값을 ref로 잡고자 할 때  사용한다. 
- querySelector를 통해 부모 엘리먼트를 가져온 다음 querySelectorAll과 같은 DOM 조작 메서드를 사용할 수 도 있겠지만, 이렇게 하면 DOM 구조가 변경되면 깨질 수 있기 때문에 안정적이지 않다.

### 15. 함수 컴포넌트와 클래스 컴포넌트의 차이점
- 가장 큰 차이점은 함수의 재사용 관점이다. 클래스 컴포넌트에서 코드를 재사용하려면 컴포넌트를 감싸고 또 감싸는 고차 컴포넌트의 방식으로 사용하게 되는데, 래퍼 헬(wrapper hell)이 발생하기 쉽ㄴ다. 래퍼 헬은 데이터를 추적하기 어렵고, 재사용을 어려우며, 컴포넌트를 비대하게 만든다. 
- 훅스의 등장으로 코드의 재사용이 쉽게 되었다. 클래스 컴포넌트에서 함수 컴포넌트로 넘어가게 된 계기는 바로 훅스의 등장으로 인해 코드 재사용이 쉽게 되었기 때문이다.

- 그 외 차이점으로,  클래스 컴포넌트는 라이프 사이클이 있고, 함수컴포넌트는 라이프 사이클이 없다.
- 클래스 컴포넌트는 render()안에서 return하고, 함수 컴포넌트는 바로 return한다.
- https://www.youtube.com/watch?v=dpw9EHDh2bM

### 16. stateful 컴포넌트와 stateless 컴포넌트는 어떤 차이가 있을까?
- stateful 컴포넌트는 컨테이너 컴포넌트로 데이터 로직을 관리하는 컴포넌트이다. 어떤 데이터가 사용자에게 보여질 지에 대해 다루는 컴포넌트이다.
- stateless 컴포넌트는 프레젠테이션 컴포넌트로 뷰를 다로는 컴포넌트이다. 데이터가 어떻게 다뤄줘야 하는지에 대해서 다룬다.

### 17. Container/Presentational 패턴과 리액트가 무슨 관련이 있는가?
- SoC - separation of concerns, 관심사를 분리하기 위한 방법으로 Container/Presentational 패턴이 등장했다. 
- 대개 Container/Presentational 패턴은 React Hooks로 대체 가능하다. React에 Hooks가 추가되면서 클래스형 컴포넌트를 사용하지 않고도, 즉 Container 컴포넌트 없이도 stateless 컴포넌트를 쉽게 만들 수 있게 되었다. 

### 18. Controlled 컴포넌트 vs Uncontrolled 컴포넌트
- Controlled 컴포넌트는 데이터를 가지고 있으면서 다른 컴포넌트에 주입, 즉 push 해주는 방식이며, uncotrolled 컴포넌트는 데이터를 내가 필요한 순간에 pull해서 가져오는 것이다. form태그의 input과 같은 컴포넌트는 리액트에서 보통 제어컴포넌트를 사용하는데 value를 통해 state를 주입하며 계속 리렌더링 하는 방식이기 때문에 제어 컴포넌트라고 할 수 있다.

### 19. Props drilling이 무엇인지
- 많은 컴포넌트에 동일한 prop을 전달해야할 경우, state를 높이 끌어올리면 'prop drilling', 즉 컴포넌트를 계속 밑으로 전달해야 하는 상황이 발생할 수 있다.

### 20. Prop drilling은 어떻게 해결할 수 있는지
- Context API 혹은 Redux와 같은 전역 state 관리 툴을 이용해 해결할 수 있다.

### 21. Context API vs Redux의 차이점
- context api는 전역상태관리의 역할만 할 수 있지만 Redux는 전역 상태 관리 외에 redux-thunk, redux-saga 등의 미들웨어를 사용할 수 있는 등 다양한 기능을 제공한다. 
- context API는 context가 변경되면 해당 context를 사용하는 자식들에 대해서 전부 자동으로 리렌더링한다. react-Redux도 contextAPI와 useMemo를 통해 만들어졌기 때문에 리렌더링 하지만 내부적으로 최적화가 되어 있다.

### 22. VDom 이란 무엇일까요?
- 가상 DOM은 실제 DOM의 추상화된 표현으로 실제 DOM을 통해 변경 사항을 조작하면 비용이 많이 들기 때문에 리액트는 가상 DOM을 이용해 변경된 부분만 확인하여 이를 실제 DOM에 업데이트 해주는 방식으로 상태를 변경한다.

### 23. Reconciliation이란 무엇인지?
- 변경 사항을 식별하고 최소한의 변경사항을 적용하는 과정을 '재조정'이라고 한다. 렌더와 커밋단계로 이뤄지는데, 렌더는 React 컴포넌트를 호출하여 화면에 표시할 내용을 파악하는 것이고, 커밋은 변경사항을 UI에 반영하는 과정이다.

### 24. key 프로퍼티는 어떤 역할을 하나요?
- 리스트에서의 key는 각 컴포넌트가 어떤 배열에 해당하는지 React에게 알려주어 나중에 매칭할 수 있도록 한다. key를 부여하면 배열 데이터 항목에 변경이 있어도 React가 정확히 무슨 일이 일어났는지 추론하고 DOM트리를 올바르게 업데이트 할 수 있다.
- 컴포넌트에 key를 부여하는 경우도 있다. 동일한 위치에 컴포넌트가 생성되면 state리렌더링이 일어나지 않는데, 예를 들어 채팅 프로그램을 만들 때 같은 경우, 동일한 위치에 컴포넌트가 있다고 하더라도 리렌더링을 촉발시키고 싶을 때에는 key를 이용하여 각 컴포넌트를 독립적인 상태로 만들어 줄 수 있다.
