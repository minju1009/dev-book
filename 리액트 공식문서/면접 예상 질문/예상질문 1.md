#### 1. 프레임 워크, 라이브러리의 차이?
- 프레임워크는 소프트웨어 개발을 위한 구조와 기능을 제공하는 플랫폼이며, 라이브러리는 개발자가 사용할 수 있는 기능을 모아놓은 코드의 집합이다. 
- 즉, 프레임워크에서는 `IoC(Inversion of Control`을 이용하여 컴퓨터 프로그램의 제어 흐름을 프레임워크가 담당하도록 하며, 라이브러리는 개발자가 코드를 제어한다.

#### 2. 메타 프레임워크란?
- 다른 프레임워크를 개발하기 위한 기반을 제공하는 프레임워크다. 프레임워크를 개발하는 데 사용되는 도구, 패턴, 추상화 계층 등을 포함한다.
- 리액트의 경우 Next.js, Gatsby, Remix, 뷰의 경우 Nuxt.js 

#### 3. 선언형 프로그래밍 vs 명령형 프로그래밍
- 선언형 프로그래밍은 `원하는 결과물을 선언`하는 방식의 프로그래밍 패러다임이며, 명령형 프로그래밍은 프로그래밍이 `어떻게 동작해야 하는지를 명시`하는 프로그래밍 패러다임이다.
- 리액트에서는 선언형 프로그래밍 방식으로 코드를 작성한다. 

#### 4. 에러를 명령형으로 처리했던 경험과 선언형으로 처리했던 경험이 있나?
- 에러 바운더리로 처리할 수 있는 방법이 있는데, 기존 에러바운더리는 클래스에서만 사용 가능했다. 
- `이번 프로젝트때 센트리 사용해보고 답변 정리하기!`
- [https://www.youtube.com/watch?v=012IPbMX_y4](https://www.youtube.com/watch?v=012IPbMX_y4)

#### 5. Suspense란?
- 리액트의 Suspense는 비동기 데이터 로딩 및 코드 스플리팅과 같은 선언형 프로그래밍을 지원하기 위한 리액트의 기능으로, 선언적인 방식으로 컴포넌트가 비동기 작업을 수행할 때 로딩 상태를 처리하고, 로딩이 완료된 후에 UI를 렌더링하는데 사용된다.

#### 6. 리액트에서 리렌더링을 할 때 왜 setState를 사용하는지?
- 데이터가 변경되었다는 것을 React에게 알려줘야하기 때문이다. setState를 통해 React에게 변경사항을 알려 가상돔에 반영하고 화면을 리렌더링할 수 있기 때문이다.

#### 7. 리액트 state를 사용할 때, 왜 불변성을 사용하는지?
- state의 세부 내용을 일일이 비교하기 보다, 기존 state의 불변성을 지켜주고 새로운 주소값을 이용해 state를 업데이트 해주는 것이 성능적으로 더 좋기 때문이다. 특히 데이터가 대용량일 때, 일일이 하나씩 찾아서 비교하는 것은 비용이 굉장히 비싸지는데, 그렇기에 리액트는 얕은복사를 통해 데이터의 변경을 감지하도록 한다.

#### 8 . JSX란?
- JSX란 자바스크립트와 XML을 결합한 문법으로, JSX를 이용하면 인간이 이해하기 쉬운 방식으로 돔 조작과 자바스크립트의 사용을 한 공간에서 손쉽게 작성할 수 있다. 또한 선언적인 방식으로 작성하기에 가독성도 좋다.

#### 9. React.createElement vs `_jsx
- 리액트 16버전까지는 


### JSX란?
- JSX란 자바스크립트를 확장한 문법으로, JS 파일 안에 HTML과 유사한 마크업을 작성할 수 있도록 해준다. 자박스크립트와 XML을 결합한 문법이다. JSX를 이용하면 돔 조작과 자바스크립트의 사용을 한 공간에서 가독성 좋고 간편하게 쓸 수 있게 해준다. 인간이 이해하기 쉬운 방식으로 작성할 수 있게 해준다. 선언적이다. 
- React.createElement vs _.jsx : 16버전 이하로는 전자를, 17부터는 _jsx를 사용하여 자바스크립트로 변환을 해준다.
- 트랜스파일러 : 바벨이 결국 자바스크립트로 변환해주는데, 프리셋 중에서 바벨 프리셋 리액트 안에 그 내용이 있다. 
- 문과 표현식 : jsx는 결국 값, 즉 표현식을 반환하는 것이기 때문에 그 안에 문이 들어갈 수 없고, 값으로 판단되는 것만 들어갈 수 있다.

### ref
- Ref가 무엇인지 : 특정 정보를 기억하도록 하고 싶지만 해당 정보가 새 렌더링을 촉발하지 않도록 하려는 경우에 사용한다. 단순한 객이며 변이가 가능하다.
- Callback ref가 왜 필요한지 : 하위 컴포넌트에 어떤 DOM이 들어올지 모르고 동적으로 생성되는 곳에는 ref객체대신 ref 속성에 함수를 전달할 수 있는 것을 말한다. 새로그려질 때 callback 
- 왜 querySelector를 통해 가져오지 않는지? 특정 DOM 요소를 가져올 때 더 신뢰할 만하기 때문이다. 
- callback ref란 ref 객체대신 ref 속성에 함수를 전달할 수 있는 것을 말한다. 동적으로 생성되는 DOM이 변경될 때마다 새롭게 값을 넣어주어야 하는데, ref callback function을 사용하면 

- callback ref는 하위 컴포넌트에 어떤 DOM이 들어올지 모르고 동적으로 생성되는 곳에 필요하다. ref에 객체대신 함수를 전달하여 DOM을 관리하기 위해 필요하다.

### 함수 컴포넌트와 클래스 컴포넌트의 차이점
- this
- 함수 재사용
	- HoC
	- Hooks : 재사용성 측면, 명시적 훅을 
- 고차함수 vs 고차 컴포넌트
- https://www.youtube.com/watch?v=dpw9EHDh2bM
- Wrapper Hell이 발생한다.

1. 라이프사이클 유무 : 클래스 컴포넌트는 라이프사이클이 있고, 훅스는 라이프사이클이 없다.
2. reusing Logic, Giant components, confusing classes 때문에 클래스 컴포넌트에서 function 컴포넌트로 이동했다.
3. return(), render(return())
4. useState, state. 객체 형태의 state만
5. prop 매개변수,  this.props로
6. this. 함수

> 클래스 컴포넌트에서 로직을 재사용하려고 하면 감싸고 감싸고 또 감싸야 해서 Wrapper Hell이 발생한다. 이는 재사용을 어렵게 만들고, 컴포넌트를 비대하게 만들고, 데이터 흐름을 파악하기 어렵게 만든다.

### stateful 컴포넌트와 stateless 컴포넌트는 어떤 차이가 있을까?
- 프레젠테이션 컴포넌트 : state에 대한 로직이 없고 단순히 화면만 보여주는 컴포넌트
- 컨테이너 컴포넌트: state가 존재하며 동작과 관련된 부분이다.
- - [https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/)

### Controlled 컴포넌트 vs Uncontrolled 컴포넌트
- Form 중심 
- form에 value prop을 넘기면 state업데이트를 바로바로 할 수 있다. 
- value prop을 전달하면 제어 컴포넌트가 된다. 즉, 외부에서 value를 통해 동기적으로 값을 업데이트 할 수 있게 된다.

### React props drilling
- Context API vs Redux
- 내가 지정한 공간, store
- 하나의 상태값 변경되면 안에있는 애들이 전부다 변한다.
- useMemo를 통해서 캐싱, Provider {children}

- component pattern 을 이용할 때 만들기 좋다.
- middleware 사용에 좋다.

### VDom 이란 무엇일까요?
- VDom이 활용될 때 나오는 과정에서 Reconciliation은 어떤 과정일까요?
	Reconciliation 
- Key 프로퍼티는 어떤 역할을 하나요?



- useEffect를 사용할때 의존성 배열에 대하여 
