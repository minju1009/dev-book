반응형 Effect의 생명주기

Effect는 컴포넌트와 다른 생명주기를 가진다. 컴포넌트는 마운트, 업데이트, 마운트 해제를 할 수 있다면, Effect는 동기화를 시작하고, 나중에 동기화를 중지하는 두 가지 작업만 할 수 있다. 이 사이클은 시간이 지남에 따라 변하는 props와 state에 의존하는 Effect의 경우 여러 번 발생할 수 있다. React는 Effect의 의존성을 올바르게 지정했는지 확인하는 린터 규칙을 제공한다. 이렇게 하면 Effect가 최신 props와 state에 동기화된다.

- Effect의 생명주기가 컴포넌트의 생명주기와 다른 점
- 각 개별 Effect를 분리해서 생각하는 방법
- Effect를 다시 동기화해야 하는 시기와 그 이유
- Effect의 의존성이 결정되는 방법
- 값이 반응형이라는 것의 의미
- 빈 의존성 배열이 의미하는 것
- React가 린터로 의존성이 올바른지 확인하는 방법
- 린터에 동의하지 않을 때 해야 할 일

## Effect의 생명주기
Effect는 외부 시스템을 현재 props 및 state에 동기화 하는 방법을 설명한다.

컴포넌트를 채팅 서버에 연결하는 Effect를 예로 들어보자.
```jsx
const serverUrl = 'https://localhost:1234';  

  

function ChatRoom({ roomId }) {  

	useEffect(() => {  
	//동기화 시작 방법이 명시되어 있음
		const connection = createConnection(serverUrl, roomId);  
		connection.connect();  

	// 동기화 중지하는 방법이 지정되어 있음
		return () => {  
		connection.disconnect();  
		};  

	}, [roomId]);  

// ...  

}
```

## Effect의 관점에서 생각하기
사용자가 드롭다운에서 general 채팅방을 선택했다가, 다시 travel 방을 선택했다고 해보자. ChatRoom 컴포넌트는 roomId prop이 새로운 값을 받았다는 것이다. 자, 그러면 다른 방에 다시 연결하려면 React가 Effect를 다시 동기화해야 한다. 

React가 Effect를 재동기화 하기 위해서는, 클린업 함수를 먼저 호출한다.
예를 들어, 위 케이스에서 general 방과의 동기화를 중지하기 위해, React는 general 방에 연결한 후 Effect가 반환한 클린업 함수를 호출한다.

자 이를 컴포넌트 관점에서 생각해보면, Effect를 '렌더링 후' 또는 '마운트 해제 전'과 같은 특정 시점에 실행되는 '콜백' 또는 '생명주기 이벤트'로 생각하기 쉬웠다. 그러나, 이렇게 생각하면 복잡해진다. 

**대신 항상 한 번에 하나의 시작/중지 사이클에만 집중해야 한다. 컴포넌트를 마운트, 업데이트 또는 마운트 해제 하는 것은 중요하지 않고, 동기화를 시작하는 방법과 중지하는 방법만 설명하면 된다. **


## React가 Effect의 재동기화 가능 여부를 확인하는 방법
개발 모드에서 리액트는 즉시 강제로 동기화를 수행하여 Effect가 다시 동기화 될 수 있는지 확인한다. 도어락이 잘 작동하는지 확인하기 위해 문을 열었다가 한 번 더 닫는 것과 비슷한데, React는 개발 중에 Effect를 한 번 더 시작하고 중지하여 클린업 함수를 잘 구현했는지 확인한다.

## React가 Effect의 재동기화 필요성을 인식하는 방법
의존성 배열을 통해서, 재동기화 필요성을 인식할 수 있다.

## 각각의 Effect는 별도의 동기화 프로세스를 나타냅니다.
관련없는 두 개의 로직을 Effect에 추가하지 말아라. 각각의 Effect를 사용해야 한다. 코드의 각 Effect는 별도의 독립적인 동기화 프로세스를 나타내야 한다. 어떻게 알 수 있나 ? 한 Effect를 삭제해도 다른 Effect의 로직이 깨지지 않다면, 분리해서 작성하는 것이 더 합리적이라는 것을 나타낸다.

## 컴포넌트 본문에서 선언된 모든 변수는 반응형입니다
props와 state만 반응형 값은 아니다. 이들로 부터 계산하는 값들 역시 반응형이다. props나 state가 변경되면 컴포넌트가 다시 렌더링되고 그로부터 계산된 값도 변경된다. 그렇기 때문에 Effect가 사용하는 컴포넌트 본문의 모든 변수는 Effect 의존성 목록에 있어야 한다.

*ref.current와 같이 mutable한 값은 의존성이 될 수 없다. 이를 통해 리렌더링을 촉발하지 않고도 무언가를 추적할 수 있기 때문에, 반응형 값이 아니며, React는 따라서 이 값이 변경될 때 Effect를 다시 실행해야 할 지 알 수 없다.

## React는 모든 반응형 값을 의존성으로 지정했는지 검토합니다
린터는 Effect 코드에서 사용되는 모든 반응형 값이 해당 의존성으로 선언되었는지 확인한다. 