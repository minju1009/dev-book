[](https://velog.io/@superlipbalm/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8context%EC%99%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%8F%99%EC%9E%91)[https://velog.io/@superlipbalm/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior#컨텍스트context와-렌더링-동작](https://velog.io/@superlipbalm/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8context%EC%99%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%8F%99%EC%9E%91)

위 글을 읽고 기억하고 싶은 내용만 정리한 글입니다.

### 렌더링 프로세스 개요

- 컴포넌트 렌더 출력은 일반적으로 JSX 구문으로 작성되며, 자바스크립트가 컴파일되고 배포를 위해 준비될 때 `React.createElement()`호출로 변환된다.
- `createElement`는 일반 자바스크립트 객체인 React 요소를 반환한다.

```jsx
// JSX 구문이다.
return <MyComponent a={42} b="testing">Text here</MyComponent>

// 아래와 같은 호출로 변환된다.
return React.createElement(MyComponent, {a: 42, b: "testing"}, "Text Here")

// 그리고 이것은 다음과 같은 요소 객체가 된다.
{type : MyComponent, props: {a: 42, b: "testing"}, children: ["Text here"]}

// 그리고 내부적으로는 리액트가 실제 함수를 호출해 렌더링 한다.
let elements = MyComponent({...props, children})

// HTML처럼 보이는 "호스트 컴포넌트"의 경우
return <button onClick={() => {}}>Click Me</button>
// 아래와 같이 호출되어
React.createElement("button", {onClick}, "Click Me")
// 최종적으로 아래와 같이 된다.
{type: "button", props: {onClick}, children: ["Click me"]}

```

컴포넌트 트리 전체에서 렌더 출력을 수집한 후, 리액트는 새로운 객체 트리(흔히 "가상 DOM"이라고 함)와 비교해 실제 DOM을 현재 원하는 출력과 같아 보이게 하기 위해 적용해야 할 모든 변경 사항 목록을 수집한다. 비교 및 계산 프로세스는 "재조정"으로 알려져 있다.

그 후, 리액트는 계산된 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용한다.

> Dan Abramov는 가상 DOM이라는 단어로 이해하기보다는 "값 UI"라고 이해하기를 바랬다. 핵심 원칙은 UI가 문자열이나 배열과 마찬가지로 값이라는 것이다. 값이기 때문에 변수에 저장하고, 전달하고, 자바스크립트 제어 흐름에서 사용할 수 있다. 그 표현가능함이 요점이다.

### 렌더 및 커밋 단계

> 렌더링과 커밋은 다른 단계다!!

이런 재조정의 과정을 리액트 팀은 개념적으로 다음과 같은 두 단계로 나눈다.

- `렌더 단계`에서는 컴포넌트를 렌더링하고 변경 사항을 계산한다.
- `커밋 단계`에서는 렌더 단계에서 계산된 변경 사항을 DOM에 적용한다.

커밋 단계에서 리액트가 DOM을 업데이트하고 난 후에, 모든 ref들을 지정한 DOM노드와 컴포넌트 인스턴스를 가리키도록 업데이트한다. 그리고 동시에 `componentDidMount, componentDidUpdate`클래스 라이프사이클 메소드들을 호출하고, `useLayoutEffect`훅을 호출한다.

그런 다음 리액트는 짧은 제한 시간을 두고, 그 후에 모든 `useEffect`훅 들을 실행한다. 이 단계는 `Passive Effects`단계라고도 한다.

리액트 18은 `useTransition`과 같은 `동시 렌더링`기능을 추가했다. 이를 통해 리액트는 렌더링 단계에서 잠시 멈추고 브라우저가 여러 이벤트를 처리할 수 있게 되었다. 리액트는 나중에 적절하게 작업을 재개하거나 폐기하거나 다시 계산할 것이다. 그리고 이러한 렌더 작업이 끝나고 나면 한 번에 커밋 단계를 실행할 것이다.

아주 중요한 핵심은 "렌더링"은 "DOM 업데이트"와 같지 않다는 점이다. 컴포넌트가 렌더링 되었지만 가시적으로 어떠한 변화도 없을 수 있다.

리액트가 컴포넌트를 렌더링 할 때,

- 컴포넌트가 지난번과 동일한 렌더 출력을 반환해 아무런 변경이 필요하지 않을 수 있다.
- 동시 렌더링에서 리액트가 컴포넌트를 여러 번 렌더링 할 수 있지만, 만약 다른 업데이트가 현재 일어나고 있는 일을 무효화 시킨다면 렌더 아웃풋을 버리게 된다.

다음 예제로 렌더링, 커밋, 훅 실행 단계를 살펴보도록 하자.

![[Pasted image 20240403112351.png]]

- Mount 시
    - 지역 변수와, 훅들이 초기화 된다.
        - useState, useReducer, useRef 에 초기값이 들어가고 그 이후에는 이 훅들이 무시된다.
        - 퍼포먼스 최적화를 위해 useState와 useReducer에 함수를 넘길 수도 있는데, 마운트할 때 한번만 호출한다.
        - useMemo가 돌려주는 값은 그 안에 있는 함수를 호출한 반환값이다.
        - useCallback에 넘겨진 함수는 호출되지 않고 함수 그 자체가 반환된다.
    - DOM node 들이 삽입된다.
        - 반환된 React 요소들로부터 DOM node들이 생성된다. 이 단계를 `commit`단계라고 부른다.
    - DOM refs가 설정된다.
        - 첫 렌더시에는 DOM 노드가 아직 생성되지 않았기에, ref.current가 `undefined`로 설정되며, 리액트는 커밋단계 직후 바로 `ref.current`를 설정한다.
    - useLayoutEffect setups
        - 화면에 DOM node가 그려지는 paint 단계 전 먼저 실행된다. 만약 cleanup 함수가 있다면 이때 먼저 실행된다.
    - DOM Paint
        - 렌더링이 끝나고, React가 DOM을 모두 업데이트한 후에 화면에 paint가 일어난다.
    - useEffect setups
        - paint 단계가 끝나고 useEffect가 실행되어야 브라우저가 스크린을 업데이트하는 것을 방해하지 않기 때문에, useEffect는 가장 마지막에 실행된다.

# 리액트는 어떤 방식으로 렌더링할까요?

### 렌더링 큐에 렌더링 등록하기

첫 렌더링이 완료된 후, 리액트에게 큐에 리렌더링을 등록하도록 지시하는 몇 가지 방법이 있다.

#### 함수 컴포넌트

```
- useState setter
- useReducer dispatch

```

#### 클래스 컴포넌트

```
- this.setState()
- this.forceUpdate()

```

#### 기타

```
- ReactDOM의 최상위인 render(<App>) 메서드를 다시 호출(루트 컴포넌트에서 forceUpdate를 호출하는 것과 동일)
- 새로 추가된 useSyncExternalStore 훅에서 트리거된 업데이트

```

함수 컴포넌트에는 `forceUpdate` 메서드가 없지만 항상 카운터를 증가시키는 `useReducer`훅을 사용해 동일하게 동작할 수 있다.

```jsx
const [, forceRender] = useReducer((c) => c+1, 0)

```

### 일반적인 렌더링 동작

우리가 기억해야 할 중요한 사항은, 리액트의 기본 동작은 상위 컴포넌트가 렌더링 될 때 리액트가 해당 컴포넌트 내부의 모든 하위 컴포넌트를 순환하며 렌더링 한다는 것이다!

예를 들어, `A > B > C > D`인 컴포넌트 트리가 있을 때, 사용자가 `B`에서 카운터를 증가시키는 버튼을 클릭하면, B는 물론 C, D도 함께 렌더링한다.

또한 일반적인 렌더링에서 리액트는 `props가 변경되었는지` 여부를 신경쓰지 않고, 부모가 렌더링되면 무조건 하위 컴포넌트를 렌더링한다!

이는 루트 `<App>`컴포넌트에서 `setState()`를 호출하면 동작을 변경하는 다른 변경 사항 없이 리액트가 컴포넌트 트리의 모든 컴포넌트들을 리렌더링 하게됨을 의미한다.

트리에서 대부분의 컴포넌트가 직전과 정확히 동일한 렌더 출력을 반환할 가능성이 매우 높으므로, 리액트는 DOM을 변경할 필요가 없다. 그러나 리액트는 여전히 컴포넌트에 자체 렌더링을 요청하고 렌더 출력을 비교하는 작업을 수행해야 한다. 둘 다 time, effort 가 들어간다.

기억해 둘 것은 렌더링은 `나쁜 것`이 아니라는 점이다. 렌더링은 그저 리액트가 실제로 DOM을 변경해야 하는지 여부를 아는 방법일 뿐이다.

### 리액트 렌더링 규칙

리액트의 기본 규칙 중 하나는 렌더링이 `순수`해야 하며 어떠한 사이드 이펙트도 없어야 한다는 것이다. 어떤 동작이 순수하고 어떤 동작이 순수하지 않은지, Sebastian Markbage는 `[The Rules of React](<https://gist.github.com/sebmarkbage/75f0838967cd003cd7f9ab938eb1958f>)`라는 제목의 글에서 가져와서 요약해 보면 다음과 같다.

#### 렌더 로직은 다음을 수행해서는 안된다.

- 기존 변수 및 객체를 변경할 수 없다.
- `Math.random()`또는 `Date.now()`와 같은 임의의 값을 생성할 수 없다.
- 네트워크 요청을 할 수 없다.
- 상태 업데이트를 큐에 추가할 수 없다.

#### 렌더 로직은 다음을 수행할 수 있다.

- 렌더링 도중 새로 생성된 객체 변경
- 오류 발생
- 캐시된 값과 같이 아직 생성되지 않은 데이터에 대한 `지연 초기화`

### 컴포넌트 메타데이터와 파이버(Fibers)

리액트는 애플리케이션에 존재하는 모든 컴포넌트 인스턴스를 추적하는 내부 데이터 구조를 저장한다. 이 데이터 구조의 핵심 부분은 `파이버(Fiber)`라고 불리는 객체로, 다음과 같은 메타 데이터 필드를 포함한다.

- 컴포넌트 트리의 해당 지점에서 렌더링되어야 할 컴포넌트 타입
- 해당 컴포넌트와 관련된 prop, 상태
- 상위, 형제 및 하위 컴포넌트에 대한 포인터
- 리액트가 렌더링 프로세스를 추적하는 데 사용하는 기타 내부 메타데이터

리액트 파이버는 리액트 16에서 출시되어 이후 모든 버전에서 이를 사용하고 있다. `Fiber`타입을 간단히 나타내면 다음과 같다.

```jsx
export type Fiber = {
	// 파이버 타입을 식별하기 위한 태그이다.
	tag: WorkTag;

	// 해당 요소의 고유 식별자이다.
	key: null | string;

	// 파이버와 관련된 것으로 확인된 함수/클래스이다.
	type: any;

	// 단일 연결 리스트 트리 구조이다.
	child: Fiber | null
	sibling : Fiber | null
	index : number;

	...
}

```

명심할 점은 이 "파이버" 객체는 실제 컴포넌트의 props와 상태 값을 저장한다는 것이다. 컴포넌트에서 `props`와 `state`를 사용할 때 리액트는 사실 파이버 객체에 저장되 값에 대한 접근을 제공하는 것이다. 

### 컴포넌트 타입과 재조정
리액트는 출력이 실제로 변경된 시기와 방법을 어떻게 알 수 있을까?
	- 리액트 렌더링 로직은 먼저 `===` 참조 비교를 통해 요소의 `type`필드를 기준으로 비교한다. 따라서 지정된 지점의 요소가 <div> 에서 <span> 또는 <ComponentA>에서 <Component B> 로 변경되는 것과 같이 다른 타입으로 변경된 경우 리액트는 전체 트리가 변경되었다고 가정해 비교 프로세스의 속도를 높인다. 

### Key와 재조정
리액트가 컴포넌트 인스턴스를 식별하는 또 다른 방법은 `key` pseudo-prop을 사용하는 것이다. 리액트는 `key`를 컴포넌트 타입의 특정 인스턴스를 구별하는데 사용할 수 있는 고유 식별자로 사용한다.

따라서 리스트에서도 고유한 index를 key로 사용하는 것은 위험할 수 있다.

### 렌더링 일괄 처리 (Render Batching)와 타이밍
- 렌더링의 일괄 처리는 여러 `setState()`호출 결과가 단일 렌더 패스의 렌더링 큐에 전달되어 실행되는 경우를 말한다. 
- 리액트 17 및 이전 버전에서 리액트는 `onClick` 콜백과 같은 리액트 이벤트 핸들러에서만 일괄 처리는 수행했으나, 리액트 18에서는 `setTimeout`을 포함한 단일 이벤트 루프 틱에 대기중인 모든 업데이트의 "자동 일괄 처리"를 지원한다.

### 비동기 렌더링, 클로저 그리고 상태스냅샷
업데이트 된 값을 설정한 후 바로 변수를 사용하려는 것은 잘못된 접근이다. useState는 클로저를 사용하고 있기 때문에, 다시 말하자면 이전의 상태 스냅샷을 가지고 렌더링 하기 때문에 해당 시점의 state 값만 사용할 수 있다.

### 렌더링 동작 엣지 케이스
#### 커밋 단계 생명 주기
- 커밋 단계의 생명 주기 메서드인 `componentDidMount, componenetDidUpdate, useLayoutEffect`에는 몇 가지 추가적인 엣지 케이스가 있다. 일반적인 사용예는 다음과 같다.
	- 부분적이지만 불완전한 데이터가 있는 컴포넌트를 처음 렌더링 한다.
	- 커밋 단계 생명 주기에서 ref를 사용해 페이지에 있는 실제 DOM 노드의 크기를 측정한다.
	- 측정을 기반으로 컴포넌트의 일부 상태를 설정한다.
	- 업데이트된 데이터로 즉시 리렌더링한다.
#### 조정자(Reconciler)일괄 처리 메서드
- 리액트 17 이전 버전의 경우 이벤트 핸들러 외부의 여러 업데이트를 `unstable_batchedUpdates()`로 래핑해 배치 처리할 수 있었으나
- 리액트 18에서는 기본적으로 자동 일괄처리 되므로, 리액트 18에서는 강제로 즉시 렌더링하고 일괄 처리에서 제외하는 데 사용할 수 있는 `flushSync() API`가 있다.


# 렌더링 성능 개선
만약 컴포넌트의 렌더링 출력이 변경되지 않았고, DOM의 해당 부분을 업데이트할 필요가 없다면 해당 컴포넌트를 렌더링하는 작업은 시간 낭비이다.
리액트 렌더링을 최적화 하는 것은 주로 컴포넌트 렌더링을 적절히 건너뛰어 작업량을 줄이는 것이다.

### 컴포넌트 렌더링 최적화 기법
- `React.memo()` : 주된 메서드는 고차컴포넌트형태로 내장된 React.memo()이다. 래퍼 컴포넌트의 기본 동작은 props가 변경되었는지 확인하고, 변경되지 않은 경우 리렌더링 되지 않도록 하는 것이다. 함수, 클래스 컴포넌트 모두 가능하다.
- `React.Component.shouldComponentUpdate` : 렌더링 프로세스 초기에 호출되는 선택적 클래스 컴포넌트 생명 주기 메서드이다. `false`를 반환하면 리액트는 컴포넌트 렌더링을 건너뛴다. 
- `React.PureComponent`

이 모든 방식은 "얕은 비교"를 사용한다. 이는 두 개의 서로 다른 객체의 모든 개별 필드를 확인하고 객체의 내용이 서로 다른 값인지 확인하는 것을 의미한다. `obj1.a === obj2.a && obj1.b === obj2.b && ...` 이는 매우 간단한 연산이기 때문에 빠른 프로세스이다.

이 외에 리액트 컴포넌트가 이전과 정확히 동일한 요소 참조를 반환하면 리액트는 해당하는 특정 하위 컴포넌트의 리렌더링을 건너뛴다.
	- props.children을 포함하는 경우
	- useMemo()로 요소를 감싸는 경우

- React.memo() : 하위 컴포넌트에 의해 제어됨
- 동일 요소 참조 : 부모 컴포넌트에 의해 제어됨

### Props 참조가 렌더링 최적화에 미치는 영향

컨텍스트 업데이트와 렌더링 최적화
Context API + React.memo()

useSelector / Redux connect



